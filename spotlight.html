<!DOCTYPE html>
<html>
<head>
    <title>Seths UI - A Jellyfin UI Enhancement and Remote Control Handler v6.8.1</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap');
        :root { --highlight-color: var(--md-sys-color-primary); }

        /* Basic highlight classes needed to force colors through to iframes*/
        .keyboard-nav-highlight {
            background-color: var(--highlight-color) !important;
        }
        .featurediframe .keyboard-nav-highlight {
            transform: none !important;
            box-shadow: none !important;
        }
		
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
		
            setTimeout(() => {
                // ───────────────────────────────────────────────────────────────────────────────
                // GLOBAL VARIABLES & STATE
                // ───────────────────────────────────────────────────────────────────────────────
                let isInitialized      = false;
                let currentLocation    = '';
                let previousElement    = null;
                let mutationObserver   = null;
                let skipFocusReset     = false;
                let isNavigating       = false; // flag for SPA navigation
                let nowPlayingMode     = false; // whether we are on a video page
                let osdExtrasActive    = false; // whether OSD “extras” (plot/clear art) are shown
				let usingKeyboardNav   = false;
                let focusableElements  = [];    // 2D array: rows of visible, focusable elements
                let currentRow         = -1;
                let currentCol         = -1;

                const highlightColor   = getComputedStyle(document.documentElement).getPropertyValue('--highlight-color').trim();
                const jellyfin         = (() => {
                    try { return window.parent.document ? window.parent : window; }
                    catch { return window; }
                })();

                // Selectors for any element that can receive focus
                const selectors = `
                    .btnPlay,
                    .itemsContainer .cardBox,
                    .emby-scrollbuttons-button,
                    .mainDetailButtons .detailButton,
                    .buttons .paper-icon-button-light,
                    .playerControlsContainer button,
                    .playerControlsContainer a,
                    .emby-tabs-slider button,
                    .headerRight button,
                    .headerLeft button,
                    .featurediframe,
                    #leftButton,
                    #rightButton,
                    .button-link.itemAction.emby-button,
                    .overview-expand.emby-button,
                    .listItemBody.actionsheetListItemBody,
                    button.raised.more.raised-mini.noIcon.emby-button,
                    .listItem.listItem-largeImage.listItem-withContentWrapper
                `;

                // Which OSD elements to hide in “simple” mode
                const osdElementsToHide = [
                    '.btnPip',
                    '.btnVideoOsdSettings',
                    '.btnAudio',
                    '.btnSubtitles',
                    '.btnUserRating',
                    '.btnNextTrack',
                    '.btnNextChapter',
                    '.btnFastForward',
                    '.btnRewind',
                    '.btnPreviousChapter',
                    '.btnPreviousTrack',
                    '.osdTimeText',
                    '.osdRatingsText',
                    '.btnFullscreen',
                    '.volumeButtons',
                    '#osdMoreText'
                ];

                // ───────────────────────────────────────────────────────────────────────────────
                // HELPER FUNCTIONS (STYLE & UTILITIES)
                // ───────────────────────────────────────────────────────────────────────────────

                // Convert hex color to rgba
                function hexToRgba(hex, alpha) {
                    hex = hex.replace('#', '');
                    if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
                    const bigint = parseInt(hex, 16);
                    const r = (bigint >> 16) & 255;
                    const g = (bigint >> 8) & 255;
                    const b = bigint & 255;
                    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                }

                // Return a short text description of an element (for debugging)
				function describe(el) {
				  const parts = [ el.tagName.toLowerCase() ];

				  // 1) #id
				  if (el.id) {
					parts.push(`#${el.id}`);
				  }

				  // 2) .class1.class2…
				  if (el.classList.length) {
					parts.push(`.${[...el.classList].join('.')}`);
				  }

				  // 3) aria-label or title or fallback to innerText (trimmed)
				  let label = el.getAttribute('aria-label') || el.title;
				  if (!label) {
					const txt = el.textContent?.trim();
					if (txt) label = txt.length > 30 ? txt.slice(0, 27) + '…' : txt;
				  }
				  if (label) {
					parts.push(`("${label}")`);
				  }

				  // 4) data-item-id (if you happen to tag items that way)
				  if (el.dataset && el.dataset.itemId) {
					parts.push(`[data-item-id=${el.dataset.itemId}]`);
				  }

				  // 5) if this is an anchor, show a shortened href
				  if (el.tagName.toLowerCase() === 'a' && el.href) {
					const href = el.href.length > 40
					  ? el.href.slice(0, 37) + '…'
					  : el.href;
					parts.push(`(href="${href}")`);
				  }

				  return parts.join('');
				}

                // Determine if an element is visible (not display:none, opacity:0, or hidden by an ancestor)
                function isElementVisible(el) {
				  // 1) Walk up the DOM to ensure no ancestor is hidden via CSS
				  let current = el;
				  while (current) {
					if (current instanceof Element) {
					  const style = window.getComputedStyle(current);
					  if (
						style.display === 'none' ||
						style.visibility !== 'visible' ||
						parseFloat(style.opacity) === 0
					  ) {
						return false;
					  }
					}
					current = current.parentElement;
				  }

				  // 2) Make sure the element occupies physical space (width/height > 0)
				  if (el.offsetWidth <= 0 || el.offsetHeight <= 0) {
					return false;
				  }

				  return true;
				}

                // Smoothly scroll an element into view, handling carousels if needed
                function scrollIntoView(el) {
                    if (!el) return;
                    requestAnimationFrame(() => {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
                        const carousel = el.closest('.emby-scroller');
                        if (carousel) {
                            const cr = carousel.getBoundingClientRect(), er = el.getBoundingClientRect(), buffer = 100;
                            if (er.left < cr.left + buffer) {
                                carousel.scrollBy({ left: er.left - cr.left - buffer, behavior: 'smooth' });
                            }
                            if (er.right > cr.right - buffer) {
                                carousel.scrollBy({ left: er.right - cr.right + buffer, behavior: 'smooth' });
                            }
                        }
                    });
                }

                // ───────────────────────────────────────────────────────────────────────────────
                // STYLE INJECTION (TV MODE [REMOTE CONTROL] SIMULATION AND OTHER ADJUSTMENTS)
                // ───────────────────────────────────────────────────────────────────────────────

                function addStyles(doc, isIframe = false, highlightColor = '#4edad3') {
                    if (doc.getElementById('tv-nav-styles')) return;

                    const style = doc.createElement('style');
                    style.id = 'tv-nav-styles';

                    // Box-shadow for focus in main document vs. iframe
                    const boxShadowColor = hexToRgba(highlightColor, 0.5);

                    style.textContent = `
                        :root {
                            --highlight-color: ${highlightColor};
                            --md-hover-primary: rgba(103, 80, 164, 0.12);
                            --md-hover-on-surface: rgba(28, 27, 31, 0.08);
                            --md-sys-color-primary: ${highlightColor};
                            --md-sys-color-on-primary: #FFFFFF;
                            --md-sys-color-surface: #FFFBFE;
                            --md-sys-color-surface-container-low: #F7F2FA;
                            --md-sys-color-surface-container: #E8DEF8;
                            --md-sys-color-surface-container-high: #D0BCFF;
                            --md-sys-color-outline: #79747E;
                            --md-sys-color-secondary: #625B71;
                            --md-sys-color-on-surface: #1C1B1F;
                            --md-sys-color-surface-variant: #E7E0EC;
                            --border-color: #79747E;
                        }
                        /* Hide header buttons not needed in TV mode */
                        .headerSyncButton,
                        .headerCastButton,
                        .headerUserButton,
                        .headerBackButton {
                            display: none !important;
                        }
						/* Custom: Replace 'Home' button with Material icon */
						.emby-tab-button[data-id="home"] {
							font-family: 'Material Icons' !important;
						}
						.emby-tab-button[data-id="home"]::before {
							content: "home";
							font-family: 'Material Icons';
							font-size: 1.6em;
						}
						.emby-tab-button[data-id="home"]::after {
							content: "";
						}
													
                        /* Override the default Jellyfin page title asset */
                        .pageTitleWithDefaultLogo {
                            background-image: url(/assets/img/icon-transparent.png) !important;
                        }
						/* Reposition the video slider in OSD */
                        .sliderContainer {
                            position: relative !important;
                            left: 1.8em !important;
                            max-width: 88% !important;
                        }
                        /* Reposition the time text in OSD */
                        .osdTextContainer.endTimeText.osdDurationText {
                            position: relative !important;
                            left: 1em !important;
                        }

                        /* Style for Pause button in simple OSD mode */
                        button.btnPause,
                        button.btnPause.keyboard-nav-highlight {
                            bottom: 2.6em !important;
                            left: 5em !important;
                            transform: scale(1.6) !important;
                            border-radius: 6px !important;
                            background-color: var(--md-sys-color-primary) !important;
                            color: var(--md-sys-color-on-primary) !important;
                            z-index: 999;
                        }
						/* Style for Header Buttons */
						.emby-tab-button.keyboard-nav-highlight {
							border-radius: 4px;
							background-color: var(--md-sys-color-primary) !important;
							color: var(--md-sys-color-on-primary) !important;
							box-shadow: 0 2px 8px rgba(0,0,0,0.3);
							transition: background-color 0.2s ease, transform 0.2s ease;
						}
                        /* Override Pause button style when in OSD “extras” mode */
                        button.btnPause.osdExtrasMode {
                            bottom: auto !important;
                            left: auto !important;
                            transform: none !important;
                            border-radius: 0 !important;
                            background-color: transparent !important;
                            color: inherit !important;
                        }

                        /* Highlight animation glow, bit too fancy?
                        .keyboard-nav-highlight {
                            position: relative;
                            transition: transform 0.3s ease, background-color 0.3s ease;
                            ${isIframe ? '' : `box-shadow: 0 0 10px ${boxShadowColor}`};
                            ${isIframe ? '' : `animation: pulse-glow 2s infinite`};
                            z-index: 1;
                        }
                        @keyframes pulse-glow {
                            0%   { box-shadow: 0 0 10px ${boxShadowColor}; }
                            50%  { box-shadow: 0 0 20px ${boxShadowColor}; }
                            100% { box-shadow: 0 0 10px ${boxShadowColor}; }
                        }
						*/

                        /* In an iframe, disable the box-shadow */
                        .featurediframe .keyboard-nav-highlight {
                            transform: none !important;
                            outline: 2px solid var(--md-sys-color-primary);
                            box-shadow: none !important;
                            animation: none !important;
                        }
                        /* CardBox highlight style */
                        .cardBox.keyboard-nav-highlight {
                            box-shadow: 6px 6px 8px rgba(0, 0, 0, 0.5);
                            background-color: var(--md-sys-color-primary);
                            transform: scale(1.05);
                        }
                        /* Other element-specific highlight overrides */
                        .listItem.keyboard-nav-highlight {
                            background-color: var(--md-hover-primary) !important;
                        }
                        #navButtons button.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-primary) !important;
                            color: var(--md-sys-color-on-primary) !important;
                            transition: background-color 0.2s ease, transform 0.2s ease;
                        }
                        #navButtons button.keyboard-nav-highlight .material-icons {
                            color: var(--md-sys-color-on-primary) !important;
                        }
                        .actionSheetMenuItem.keyboard-nav-highlight,
                        .navMenuOption.keyboard-nav-highlight {
                            background-color: var(--md-hover-primary) !important;
                        }
                        .cardOverlayFab-primary.keyboard-nav-highlight {
                            background: linear-gradient(rgba(0, 164, 220, 0.1), rgba(0, 164, 220, 0.1)) padding-box,
                                        var(--border-color) border-box !important;
                        }
                        .paper-icon-button-light.keyboard-nav-highlight:not(:disabled) {
                            color: var(--md-sys-color-surface) !important;
                            background-color: var(--md-sys-color-primary) !important;
                        }
                        .formDialogHeader .btnCancel.keyboard-nav-highlight {
                            background-color: var(--md-hover-primary) !important;
                        }
                        .formDialogFooterItem.button-submit.keyboard-nav-highlight {
                            background-color: #5f429a !important;
                            box-shadow: 0px 6px 16px rgba(0, 0, 0, 0.3) !important;
                        }
                        .mainDetailButtons .detailButton.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-surface-container) !important;
                            color: var(--md-sys-color-primary) !important;
                            box-shadow: none !important;
                            background-image: none !important;
                            backdrop-filter: none !important;
                        }
                        .mainDetailButtons > .btnMoreCommands.detailButton.keyboard-nav-highlight {
                            border-top-right-radius: 999px !important;
                            border-bottom-right-radius: 999px !important;
                        }
                        .mainDetailButtons > .btnReplay.detailButton.keyboard-nav-highlight {
                            border-top-left-radius: 999px !important;
                            border-bottom-left-radius: 999px !important;
                        }
                        a.button-link.itemAction.emby-button.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-surface-container) !important;
                            color: var(--md-sys-color-on-surface) !important;
                            border-color: var(--md-sys-color-outline) !important;
                        }
                        a.overview-expand.emby-button.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-surface-container) !important;
                            color: var(--md-sys-color-on-surface) !important;
                        }
                        button.raised.more.raised-mini.noIcon.emby-button.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-surface-container) !important;
                            color: var(--md-sys-color-on-surface) !important;
                            box-shadow: 0px 3px 6px rgba(0, 0, 0, 0.25) !important;
                        }
                        .listItemBody.actionsheetListItemBody.keyboard-nav-highlight {
                            background-color: var(--md-sys-color-surface-container) !important;
                            transition: background-color 0.2s ease-in-out;
                        }
                        .btnPlay.detailButton.keyboard-nav-highlight {
                            transform: translateY(-0.7em) scale(1.2) !important;
                            color: var(--md-sys-color-surface) !important;
                            background-color: var(--md-sys-color-primary) !important;
                            box-shadow: 0 0 20px var(--md-sys-color-secondary) !important;
                            z-index: 3 !important;
                        }
                    `;
                    doc.head.appendChild(style);
                }

                // Inject hover styles for Spotlight Mod iframes
                function injectIframeHoverStyles(doc) {
                    if (doc.getElementById('iframe-hover-styles')) return;
                    const style = doc.createElement('style');
                    style.id = 'iframe-hover-styles';
                    style.textContent = `
                        .slide.hover .logo {
                            transform: translateY(-50%) translateX(-50%) scale(1.35) !important;
                            opacity: 0.1 !important;
                        }
                        .slide.hover .lorem-ipsum { opacity: 1; }
                    `;
                    doc.head.appendChild(style);
                }

                // Toggle “hover” class inside a featured iframe
                function toggleHover(doc, add = true) {
                    const slide = doc.querySelector('.slide');
                    if (slide) slide.classList.toggle('hover', add);
                }

                // ───────────────────────────────────────────────────────────────────────────────
                // OSD HANDLING (SIMPLE vs. EXTRAS MODE)
                // ───────────────────────────────────────────────────────────────────────────────

				function hideOsdExtras() {
					osdElementsToHide.forEach(sel =>
						jellyfin.document.querySelectorAll(sel).forEach(el =>
							el.classList.add('osd-hidden')
						)
					);

					const btnPause = jellyfin.document.querySelector('button.btnPause');
					if (btnPause) btnPause.classList.remove('osdExtrasMode');

					const clearArtEl = jellyfin.document.getElementById('osdClearArt');
					if (clearArtEl) clearArtEl.classList.add('osd-hidden');

					const versionEl = jellyfin.document.getElementById('osdMoreText');
					if (versionEl) versionEl.classList.add('osd-hidden');

					const mediaInfoEl = jellyfin.document.getElementById('osdMediaInfo');
					if (mediaInfoEl) mediaInfoEl.classList.add('osd-hidden');
				}

				async function showOsdExtras() {
				  // ─── Reveal all OSD elements ─────────────────────────────────
				  osdElementsToHide.forEach(sel =>
					jellyfin.document.querySelectorAll(sel).forEach(el =>
					  el.classList.remove('osd-hidden')
					)
				  );

				  // ─── Highlight the Pause button in “extras” mode ──────────────
				  const btnPause = jellyfin.document.querySelector('button.btnPause');
				  if (btnPause) {
					btnPause.classList.add('osdExtrasMode');
					if (isElementVisible(btnPause)) {
					  btnPause.classList.add('keyboard-nav-highlight');
					  scrollIntoView(btnPause);
					  btnPause.focus();
					  previousElement = btnPause;
					}
				  }

				  // ─── Determine API key (token) & userId ───────────────────────
				  const doc = jellyfin.document;
				  let initJson = null;
				  const initEl = doc.getElementById('jellyfin-initialization-data');
				  if (initEl) {
					try { initJson = JSON.parse(initEl.textContent); }
					catch {}
				  }
				  let localCred = null;
				  try {
					const raw = localStorage.getItem('jellyfin_credentials');
					if (raw) localCred = JSON.parse(raw);
				  } catch {}
				  const token = initJson?.AccessToken
							   || localCred?.Servers?.[0]?.AccessToken
							   || (() => {
									const video = doc.querySelector('video');
									const src = video?.currentSrc || video?.src || '';
									return src.match(/[?&]api_key=([^&]+)/i)?.[1] || null;
								  })();
				  const userId = initJson?.User?.Id || localCred?.Servers?.[0]?.UserId;
				  if (!token) {
					console.error('⛔ showOsdExtras: no API token found');
					return;
				  }

				  // ─── Determine the current itemId ─────────────────────────────
				  const video = doc.querySelector('video');
				  const src = video?.currentSrc || video?.src || '';
				  let itemId = null;
				  if (src && !src.startsWith('blob:')) {
					itemId = src.match(/\/Videos\/([0-9a-f]{32})\//i)?.[1]
						  || src.match(/mediaSourceId=([0-9a-f]{32})/i)?.[1];
				  }
				  if (!itemId) {
					// fallback to Sessions lookup via api_key
					console.log('🔄 showOsdExtras: falling back to /Sessions');
					const deviceId = src.match(/[?&]deviceId=([^&]+)/i)?.[1];
					try {
					  const resp = await fetch(`/Sessions?api_key=${token}`, { credentials: 'same-origin' });
					  const sessions = await resp.json();
					  const session = sessions.find(s =>
						(userId && s.UserId === userId) && (deviceId ? s.DeviceId === deviceId : true)
					  ) || sessions.find(s => s.UserId === userId) || sessions[0];
					  itemId = session?.NowPlayingItem?.Id || session?.NowViewingItem?.Id;
					} catch (e) {
					  console.error('⛔ showOsdExtras: error fetching sessions', e);
					}
				  }
				  if (!itemId) {
					console.error('⛔ showOsdExtras: unable to determine itemId');
					return;
				  }

				  // ─── Ensure mediaInfo container exists ────────────────────────
				  let mediaInfoEl = doc.getElementById('osdMediaInfo');
				  if (!mediaInfoEl) {
					mediaInfoEl = doc.createElement('div');
					mediaInfoEl.id = 'osdMediaInfo';
					Object.assign(mediaInfoEl.style, {
					  position: 'fixed',
					  bottom: '6.5em',
					  left: '12px',
					  fontFamily: 'Inter, sans-serif',
					  fontSize: '14pt',
					  fontWeight: '600',
					  color: 'var(--md-sys-color-tertiary)',
					  backgroundColor: 'rgba(0,0,0,0.5)',
					  padding: '6px 10px',
					  borderRadius: '5px',
					  maxWidth: '70vw',
					  whiteSpace: 'pre-wrap',
					  zIndex: 997,
					  textShadow: '0 1px 2px rgba(0, 0, 0, 0.8)'
					});
					doc.body.appendChild(mediaInfoEl);
				  }
				  mediaInfoEl.classList.remove('osd-hidden');

				  const versionEl = doc.getElementById('osdMoreText');
				  if (versionEl) versionEl.classList.remove('osd-hidden');

				  // ─── Fetch metadata (Overview, MediaStreams, SeriesId) ────────
				  try {
					const fields = ['Overview','MediaStreams','SeriesId'].join(',');
					const metaUrl = `/Items/${itemId}?fields=${fields}&api_key=${token}`;
					const metaRes = await fetch(metaUrl, { credentials: 'same-origin' });
					const data = await metaRes.json();

					// Plot / overview
					if (versionEl) {
					  versionEl.textContent = data.Overview || '(No plot available)';
					}

					// Media streams summary
					const streams = data.MediaStreams || [];
					const vs = streams.find(s => s.Type==='Video') || {};
					const as = streams.find(s => s.Type==='Audio') || {};
					const videoCodec  = (vs.Codec||'?').toUpperCase();
					const aspectRatio = vs.AspectRatio || (vs.Width&&vs.Height?`${vs.Width}x${vs.Height}`:'?');
					const resolution  = vs.Width&&vs.Height?`${vs.Width}x${vs.Height}`:'?';
					const audioCodec  = (as.Codec||'?').toUpperCase();
					const audioCh     = as.Channels || '?';
					let airDate = 'Unknown';
					if (data.PremiereDate) {
					  const d = new Date(data.PremiereDate);
					  const day = d.getDate();
					  const suffix = (n=>(n>3&&n<21)?'th':['st','nd','rd'][((n%10)-1)]||'th')(day);
					  airDate = `${d.toLocaleString('en-US',{month:'long'})} ${day}${suffix}, ${d.getFullYear()}`;
					}
					mediaInfoEl.textContent =
					  `${airDate} / ${videoCodec} / ${aspectRatio} / ${audioCodec} / ${audioCh}ch / ${resolution}`;
				  } catch (e) {
					console.error('⛔ showOsdExtras: error fetching metadata', e);
					if (versionEl) versionEl.textContent = '(Error loading metadata)';
				  }

				  // ─── ClearArt setup & fetch ───────────────────────────────────
				  let clearArtEl = doc.getElementById('osdClearArt');
				  if (!clearArtEl) {
					clearArtEl = doc.createElement('img');
					clearArtEl.id = 'osdClearArt';
					clearArtEl.classList.add('osd-hidden');
					Object.assign(clearArtEl.style, {
					  position: 'fixed',
					  bottom: '5.7em',
					  right: '3em',
					  maxWidth: '500px',
					  maxHeight: '500px',
					  zIndex: 999,
					  pointerEvents: 'none'
					});
					doc.body.appendChild(clearArtEl);
				  }
				  try {
					const artId = (await fetch(`/Items/${itemId}?fields=SeriesId&api_key=${token}`, { credentials: 'same-origin' })
									.then(r=>r.json())).SeriesId
								 || itemId;
					clearArtEl.src = `/Items/${artId}/Images/Art?api_key=${token}`;
					clearArtEl.classList.remove('osd-hidden');
				  } catch (e) {
					console.error('⛔ showOsdExtras: error fetching clearart', e);
				  }
				}

                // ───────────────────────────────────────────────────────────────────────────────
                // NOW-PLAYING PAGE DETECTION & LOGO INJECTION
                // ───────────────────────────────────────────────────────────────────────────────

                function checkNowPlayingMode() {
                    const url  = window.top.location.href;
                    const head = jellyfin.document.head;

                    // Remove any previously injected “now-playing” style
                    const existingStyle = jellyfin.document.getElementById('now-playing-style');
                    if (existingStyle) existingStyle.remove();

                    if (url.includes('#/video')) {
                        // ─── Inject OSD overlay styles ───────────────────────────────────────
                        const style = jellyfin.document.createElement('style');
                        style.id = 'now-playing-style';
                        style.textContent = `
                            #osdMoreText {
                                position: fixed;
                                bottom: 7.8em;
                                left: 12px;
                                font-family: 'Inter', sans-serif;
                                font-weight: 200;
                                font-size: 16pt;
                                line-height: 1.3;
                                color: #F0F0F0;
                                background-color: rgba(0, 0, 0, 0.7);
                                padding: 8px 12px;
                                border-radius: 6px;
                                max-width: 65vw;
                                white-space: pre-wrap;
                                word-wrap: break-word;
                                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
                                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
                                pointer-events: none;
                                z-index: 998;
                            }
                            .osd-hidden { display: none !important; }
                            .headerLeft {
                                margin-right: 1em !important;
                                justify-content: flex-end !important;
                            }
                        `;
                        head.appendChild(style);

                        // Create the “osdMoreText” container if it doesn’t exist
                        (function injectVersionText() {
                            const body = jellyfin.document.body;
                            if (!body) {
                                setTimeout(injectVersionText, 100);
                                return;
                            }
                            if (!jellyfin.document.getElementById('osdMoreText')) {
                                const el = jellyfin.document.createElement('div');
                                el.id = 'osdMoreText';
                                el.classList.add('osd-hidden');
                                jellyfin.document.body.appendChild(el);
                            }
                        })();

                        nowPlayingMode = true;
                        if (!osdExtrasActive) hideOsdExtras();

                        // Observe the bottom OSD container to hide extras when OSD disappears
                        const osdBottom = jellyfin.document.querySelector('.videoOsdBottom');
                        if (osdBottom) {
                            const observer = new MutationObserver(() => {
                                const hidden = osdBottom.classList.contains('videoOsdBottom-hidden')
                                            || osdBottom.classList.contains('hide');
                                if (hidden && osdExtrasActive) {
                                    hideOsdExtras();
                                    osdExtrasActive = false;
                                }
                            });
                            observer.observe(osdBottom, { attributes: true, attributeFilter: ['class'] });
                        }

                        // ─── Inject “parent-show-logo” once per video page ────────────────
                        (function() {
                            if (jellyfin.document.getElementById('parent-show-logo')) return;

                            const guidRe      = /\b[0-9a-f]{32}\b/gi;
                            const seen        = new Set();
                            jellyfin.document.querySelectorAll('*').forEach(el =>
                                Array.from(el.attributes).forEach(attr => {
                                    let m;
                                    guidRe.lastIndex = 0;
                                    while ((m = guidRe.exec(attr.value)) !== null) {
                                        seen.add(m[0]);
                                    }
                                })
                            );
                            const ids         = [...seen];
                            const maxAttempts = 3;
                            const logoStyles  = {
                                position:       'absolute',
                                top:            '10px',
                                left:           '20px',
                                maxWidth:       '400px',
                                maxHeight:      '400px',
                                transformOrigin:'top left',
                                zIndex:         999
                            };

                            function tryNext(idx) {
                                if (idx >= ids.length || idx >= maxAttempts) return;
                                const id = ids[idx];
                                fetch(`/Items/${id}/Images/Logo`, {
                                    method:      'HEAD',
                                    credentials: 'same-origin'
                                })
                                .then(res => {
                                    if (res.ok) {
                                        const img = jellyfin.document.createElement('img');
                                        img.id = 'parent-show-logo';
                                        img.src = `/Items/${id}/Images/Logo`;
                                        img.alt = 'Jellyfin Logo';
                                        Object.assign(img.style, logoStyles);
                                        const headerTop = jellyfin.document.querySelector('.osdHeader .headerTop');
                                        if (headerTop) {
                                            img.style.position = 'absolute';
                                            headerTop.appendChild(img);
                                        }
                                        console.log('Logo injector: logo loaded for', id);
                                    } else {
                                        tryNext(idx + 1);
                                    }
                                })
                                .catch(() => {
                                    tryNext(idx + 1);
                                });
                            }
                            tryNext(0);
                        })();
                    }
                    else {
                        // Leaving video page: remove logo, plot, and clearart
                        const existingLogo   = jellyfin.document.getElementById('parent-show-logo');
                        const plotEl         = jellyfin.document.getElementById('osdMoreText');
                        const clearArtEl     = jellyfin.document.getElementById('osdClearArt');
						const mediaInfoEl = jellyfin.document.getElementById('osdMediaInfo');
						if (mediaInfoEl) mediaInfoEl.remove();
                        if (existingLogo) existingLogo.remove();
                        if (plotEl) plotEl.remove();
                        if (clearArtEl) clearArtEl.remove();


                        nowPlayingMode = false;
                    }
                }

                // ───────────────────────────────────────────────────────────────────────────────
                // FOCUSABLE ELEMENTS GRID & VIRTUAL FOCUS MOVEMENT
                // ───────────────────────────────────────────────────────────────────────────────

                function updateFocusableElements() {
                    checkNowPlayingMode();

                    const elements = Array.from(jellyfin.document.querySelectorAll(selectors));
                    let processed = [];

                    elements.forEach(el => {
                        if (el.classList.contains('featurediframe') && isElementVisible(el)) {
                            const iframeDoc = el.contentDocument || el.contentWindow.document;
                            if (iframeDoc) {
                                addStyles(iframeDoc, true);
                                injectIframeHoverStyles(iframeDoc);
                                Array.from(iframeDoc.querySelectorAll('[tabindex="0"]'))
                                    .filter(isElementVisible)
                                    .forEach(innerEl => {
                                        const rect = el.getBoundingClientRect();
                                        const innerRect = innerEl.getBoundingClientRect();
                                        processed.push({
                                            element: innerEl,
                                            top:     rect.top + innerRect.top,
                                            left:    rect.left + innerRect.left
                                        });
                                    });
                            }
                        }
                        else if (isElementVisible(el)) {
                            const rect = el.getBoundingClientRect();
                            processed.push({ element: el, top: rect.top, left: rect.left });
                        }
                    });

                    // Sort by row (top) then column (left)
                    processed.sort((a, b) => {
                        if (a.top !== b.top) return a.top - b.top;
                        return a.left - b.left;
                    });

                    // Group into rows with a threshold - Force header buttons to be processed as one row
					const grid = [], headerRow = [], otherRows = [], threshold = 50;
					let row = [], lastTop = -1;

					processed.forEach(item => {
						const el = item.element;

						const isTrueHeaderButton = (
							el.closest('.headerLeft') ||
							el.closest('.headerRight') ||
							el.closest('.emby-tabs-slider')
						);

						if (isTrueHeaderButton) {
							headerRow.push(el);
						} else {
							if (lastTop === -1 || Math.abs(item.top - lastTop) > threshold) {
								if (row.length) otherRows.push(row);
								row = [el];
								lastTop = item.top;
							} else {
								row.push(el);
							}
						}
					});
					if (row.length) otherRows.push(row);
					if (headerRow.length) {
						headerRow.sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
						grid.push(headerRow);
					}
					grid.push(...otherRows);
                    focusableElements = grid;
                }

				function moveFocus(dr, dc) {
					// If there’s nothing at all to focus, bail
					if (!focusableElements.length) return;

					// Make sure currentRow is valid
					if (currentRow < 0 || currentRow >= focusableElements.length) {
						// If we lose our “row” (e.g. after a quick navigation), re‐initialize
						initializeFocus();
						return;
					}

					// Handle vertical movement
					if (dr === 1 || dr === -1) {
						const rowArr = focusableElements[currentRow];
						// If our current column is out of bounds, re‐init
						if (!rowArr || currentCol < 0 || currentCol >= rowArr.length) {
							initializeFocus();
							return;
						}
						const currentEl = rowArr[currentCol];
						if (!currentEl) return;
						const rect = currentEl.getBoundingClientRect();

						let best = null, bestDelta = Infinity;
						focusableElements.forEach((row, ri) => {
							row.forEach((el, ci) => {
								const r = el.getBoundingClientRect();
								const deltaY = r.top - rect.top;
								const deltaX = Math.abs(r.left - rect.left);
								const goingDown = dr === 1;
								if ((goingDown && deltaY > 10) || (!goingDown && deltaY < -10)) {
									const totalDist = Math.abs(deltaY) + deltaX;
									if (totalDist < bestDelta) {
										best = { r: ri, c: ci };
										bestDelta = totalDist;
									}
								}
							});
						});

						if (best) {
							currentRow = best.r;
							currentCol = best.c;
						} else {
							return; // no candidate found
						}
					}
					// Handle horizontal movement
					else {
						const rowArr = focusableElements[currentRow];
						if (!rowArr) {
							initializeFocus();
							return;
						}
						let nc = currentCol + dc;
						if (nc < 0) nc = rowArr.length - 1;
						else if (nc >= rowArr.length) nc = 0;
						currentCol = nc;
					}

					// Now that currentRow/currentCol are valid, grab the new element
					const newEl = focusableElements[currentRow]?.[currentCol];
					if (!newEl) return;

					console.log('Focus moved to:', describe(newEl));

					// Remove the old highlight
					if (previousElement) {
						previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron');
						if (previousElement.classList.contains('clickable-overlay')) {
							const iframe = jellyfin.document.querySelector('iframe.featurediframe');
							if (iframe) toggleHover(iframe.contentDocument || iframe.contentWindow.document, false);
						}
					}
					if (previousElement?.id === 'mediaButton') {
						const iframe = jellyfin.document.querySelector('iframe.featurediframe');
						if (iframe) toggleHover(iframe.contentDocument || iframe.contentWindow.document, false);
					}

					// Add the new highlight
					newEl.classList.add('keyboard-nav-highlight');
					if (newEl.classList.contains('emby-scrollbuttons-button')) {
						newEl.classList.add('highlight-chevron');
					}
					scrollIntoView(newEl);

					// If it’s an iframe overlay or the mediaButton, force the hover state
					if (newEl.classList.contains('clickable-overlay') || newEl.id === 'mediaButton') {
						const iframe = jellyfin.document.querySelector('iframe.featurediframe');
						if (iframe) toggleHover(iframe.contentDocument || iframe.contentWindow.document, true);
					}

					previousElement = newEl;
				}

                function initializeFocus() {
                    checkNowPlayingMode();
                    updateFocusableElements();

                    const url = window.top.location.href;
                    let first = null;

                    // 1) If on home page, focus rightButton inside featured iframe
                    if (url.includes('#/home.html')) {
                        const iframe = jellyfin.document.querySelector('.featurediframe');
                        const btn = iframe?.contentDocument?.querySelector('#rightButton');
                        if (btn && isElementVisible(btn)) {
                            first = btn;
                        }
                    }
                    // 2) If on video page, focus pause button
                    else if (url.includes('#/video')) {
                        const btnPause = jellyfin.document.querySelector('button.btnPause');
                        if (btnPause && isElementVisible(btnPause)) {
                            first = btnPause;
                        }
                    }

                    // 3) Otherwise use default priority selectors
                    if (!first) {
                        const priSel = [
                            'button[is="emby-button"][data-action="resume"]',
                            'button[is="emby-button"][data-action="play"]',
                            '.itemsContainer .cardBox'
                        ];
                        for (const sel of priSel) {
                            const el = jellyfin.document.querySelector(sel);
                            if (el && isElementVisible(el)) {
                                first = el;
                                break;
                            }
                        }
                    }

                    // 4) Fallback to first element in the grid
                    if (!first && focusableElements.length && focusableElements[0].length) {
                        first = focusableElements[0][0];
                    }

                    // 5) Highlight and scroll into view
                    if (first) {
                        if (previousElement && previousElement !== first) {
                            previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron');
                        }
                        first.classList.add('keyboard-nav-highlight');
                        if (first.classList.contains('emby-scrollbuttons-button')) {
                            first.classList.add('highlight-chevron');
                        }
                        scrollIntoView(first);

                        // Update pointers to match the grid position
                        for (let i = 0; i < focusableElements.length; i++) {
                            const ci = focusableElements[i].indexOf(first);
                            if (ci !== -1) {
                                currentRow = i;
                                currentCol = ci;
                                break;
                            }
                        }
                        previousElement = first;
                    } else {
                        currentRow = currentCol = -1;
                    }
                }

                // Handle “Enter” key when activated on a focused element
                function handleEnter() {
                    if (currentRow === -1 || currentCol === -1) {
                        initializeFocus();
                        return;
                    }
                    const active = focusableElements[currentRow][currentCol];
                    console.log('Enter pressed on:', describe(active));

                    // If it’s a video player inside a featured iframe, toggle playback via “k” key
                    if (active.classList.contains('video-player') || active.querySelector('.video-player')) {
                        const spotIframe = jellyfin.document.querySelector('.featurediframe');
                        if (spotIframe?.contentWindow?.controlYouTubePlayer) {
                            spotIframe.contentWindow.controlYouTubePlayer.toggle();
                            skipFocusReset = true;
                        }
                    } else {
                        // Otherwise, click the element or any nested <a> / <button>
                        const isNavAction = active.matches('a[href], button[data-action="navigate"]')
                                         || active.querySelector('a[href*="/web/index.html#!/item"], button[data-action="navigate"]');
                        if (isNavAction) isNavigating = true;
                        (active.querySelector('a[href*="/web/index.html#!/item"], button, a') || active).click();
                    }

                    // If left/right navigation button, preserve focus state
                    const isLR = ['leftButton', 'rightButton'].includes(active.id)
                              || active.closest('#leftButton')
                              || active.closest('#rightButton');
                    if (isLR) skipFocusReset = true;

                    if (!isLR && !skipFocusReset) {
                        if (previousElement) {
                            previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron', 'video-focused');
                            if (previousElement.classList.contains('clickable-overlay')) {
                                const iframe = jellyfin.document.querySelector('iframe.featurediframe');
                                if (iframe) toggleHover(iframe.contentDocument || iframe.contentWindow.document, false);
                            }
                        }
                    }
                }

                // ───────────────────────────────────────────────────────────────────────────────
                // INPUT HANDLERS (Keystrokes → VIRTUAL “TV MODE” BEHAVIOR)
                // ───────────────────────────────────────────────────────────────────────────────

                function handleKeydown(e) {
				
					if (!usingKeyboardNav) {
						jellyfin.document.documentElement.style.pointerEvents = 'none';
						usingKeyboardNav = true;
					}
				
                    const activeEl = jellyfin.document.activeElement;
                    const tag      = activeEl.tagName.toLowerCase();
                    if (['input', 'textarea'].includes(tag) || activeEl.isContentEditable) return;

                    // If no element is highlighted yet, initialize focus grid
                    if (!previousElement) {
                        initializeFocus();
                        e.preventDefault();
                        return;
                    }

                    switch (e.key) {
						case 'ArrowUp':
							moveFocus(-1, 0);

							// only toggle extras if we’re on a video page
							if (nowPlayingMode) {
								if (!osdExtrasActive) {
									osdExtrasActive = true;
									showOsdExtras();
								} else {
									osdExtrasActive = false;
									hideOsdExtras();
								}
							}

							e.preventDefault();
							break;

                        case 'ArrowDown':
                            updateFocusableElements();
                            moveFocus(1, 0);
                            e.preventDefault();
                            break;

                        case 'ArrowLeft':
                        case 'ArrowRight': {
                            const direction = e.key === 'ArrowLeft' ? -1 : 1;
                            const slider = jellyfin.document.querySelector('.osdPositionSlider');
                            // If slider is visible and we are in simple OSD (no extras), let native behavior run after focusing
                            if (slider && isElementVisible(slider) && !osdExtrasActive) {
                                if (previousElement) {
                                    previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron');
                                }
                                previousElement = slider;
                                slider.classList.add('keyboard-nav-highlight');
                                slider.focus();
                                scrollIntoView(slider);
                                return;
                            }
                            // If in OSD extras, navigate within the extras overlay
                            if (osdExtrasActive) {
                                moveFocus(0, direction);
                                e.preventDefault();
                                e.stopPropagation();
                                break;
                            }
                            // Otherwise, fallback navigation: move focus in main grid
                            moveFocus(0, direction);
                            e.preventDefault();
                            break;
                        }

                        case 'Enter':
                            if (nowPlayingMode && !osdExtrasActive) {
                                // On video page, if extras are not shown, intercept Enter to toggle playback
                                e.preventDefault();
                                e.stopPropagation();

                                const btnPause = jellyfin.document.querySelector('.btnPause');
                                if (btnPause) {
                                    if (previousElement) {
                                        previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron', 'video-focused');
                                    }
                                    previousElement = btnPause;
                                    btnPause.classList.add('keyboard-nav-highlight');
                                }
                                const kEvent = new KeyboardEvent('keydown', {
                                    key: 'k',
                                    code: 'KeyK',
                                    bubbles: true,
                                    cancelable: true
                                });
                                jellyfin.document.dispatchEvent(kEvent);
                                return;
                            }
                            // Otherwise, handle Enter normally (invoke `handleEnter`)
                            handleEnter();
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                    }
                }

                // ───────────────────────────────────────────────────────────────────────────────
                // SPA NAVIGATION DETECTION (RESET FOCUS & STATE)
                // ───────────────────────────────────────────────────────────────────────────────

                function handleLocationChange() {
                    if (previousElement) {
                        previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron');
                    }
                    focusableElements = [];
                    currentRow = -1;
                    currentCol = -1;
                    previousElement = null;
                    updateFocusableElements();
                    initializeFocus();
                }

                window.addEventListener('hashchange', handleLocationChange);
                window.addEventListener('popstate', handleLocationChange);

                // Also patch history.pushState to catch manual pushes
                const _pushState = history.pushState;
                history.pushState = function (...args) {
                    _pushState.apply(this, args);
                    handleLocationChange();
                };

                // On “back” from nested navigation, reinitialize focus
                function handleBack() {
                    setTimeout(() => {
                        if (!skipFocusReset) {
                            isInitialized = false;
                            init();
                        }
                    }, 250);
                }

                window.addEventListener('popstate', handleBack, { passive: true });

                // Poll the URL every 1.25s in case the SPA changes without firing a hash/popstate
                function checkNav() {
                    const newLoc = window.top.location.href + window.top.location.hash;
                    if (newLoc !== currentLocation) {
                        currentLocation = newLoc;
                        isInitialized = false;
                        isNavigating = false;
                        if (previousElement) {
                            previousElement.classList.remove('keyboard-nav-highlight', 'highlight-chevron', 'video-focused');
                        }
                        previousElement = null;
                        currentRow = -1;
                        currentCol = -1;
                        focusableElements = [];
                        init();
                    }
                }

                setInterval(checkNav, 1250);

                // ───────────────────────────────────────────────────────────────────────────────
                // INITIALIZATION
                // ───────────────────────────────────────────────────────────────────────────────

                // Called once at startup (and again on SPA navigation)
                function init() {
                    const rootColor = getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-primary').trim();
					addStyles(jellyfin.document, false, rootColor);

                    // Rebind keydown listener
                    jellyfin.document.removeEventListener('keydown', handleKeydown, true);
                    jellyfin.document.addEventListener('keydown', handleKeydown, { passive: false, capture: true });

                    // Set up a MutationObserver to watch for DOM changes (e.g., new page content)
                    if (mutationObserver) {
                        mutationObserver.disconnect();
                        mutationObserver = null;
                    }
                    mutationObserver = new MutationObserver(() => {
                        checkNowPlayingMode();
                        if (!skipFocusReset) {
                            updateFocusableElements();
                            if (isNavigating) {
                                initializeFocus();
                                isNavigating = false;
                            }
                        }
                    });
                    mutationObserver.observe(jellyfin.document.body, { childList: true, subtree: true });

                    // For any existing featured iframes, inject styles and hover logic
                    jellyfin.document.querySelectorAll('iframe.featurediframe').forEach(iframe => {
                        handleIframeLoad(iframe);
                        iframe.removeEventListener('load', handleIframeLoad);
                        iframe.addEventListener('load', () => handleIframeLoad(iframe), { passive: true });
                    });
					
					// Re-enable mouse if it moves after keyboard navigation
					jellyfin.document.addEventListener('mousemove', () => {
						if (usingKeyboardNav) {
							jellyfin.document.documentElement.style.pointerEvents = 'auto';
							usingKeyboardNav = false;
						}
					}, { passive: true });
					
                    isInitialized = true;
                    // Force one more update of focusable elements after 2 seconds (fallback)
                    setTimeout(() => {
                        console.log('↪ Forcing fallback update of focusable elements (.1s post-init)');
                        updateFocusableElements();
                    }, 100);
                }

                // Called whenever a featured iframe loads
                function handleIframeLoad(iframe) {
					const doc = iframe.contentDocument || iframe.contentWindow.document;
					if (doc) {
						const parentColor = getComputedStyle(jellyfin.document.documentElement)
						  .getPropertyValue('--md-sys-color-primary')
						  .trim();
						addStyles(doc, true, parentColor);
						injectIframeHoverStyles(doc);
					}
				}

                // Kick off the whole system
                init();
            }, 800);
        }, { passive: true });
    </script>
</head>
<body></body>
</html>